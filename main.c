#include "main.h"

#include <stdio.h>
#include <stdlib.h>

#include "gba.h"
#include <time.h> 
#include "mylib.h"
#define REG_TM0CNT *(volatile u16*)0x4000102 
#define REG_TM1CNT *(volatile u16*)0x4000106 
#define REG_TM2CNT *(volatile u16*)0x400010A 
#define REG_TM3CNT *(volatile u16*)0x400010E 
#define REG_TM0D *(volatile u16*)0x4000100 
#define REG_TM1D *(volatile u16*)0x4000104 
#define REG_TM2D *(volatile u16*)0x4000108 
#define REG_TM3D *(volatile u16*)0x400010C 
#define TM_FREQ_1024   0x0003
#define 	TM_CASCADE   0x0004
#define 	TM_ENABLE   0x0080
#define 	DCNT_MODE0   0
#define 	DCNT_BG0   0x0100







/* TODO: */
// Include any header files for title screen or exit
// screen images generated by nin10kit. Example for the provided garbage
// image:
// #include "images/garbage.h"

#include "images/garbage.h"
#include "images/startScreen.h"
#include "images/dreamImg.h"
#include "images/background.h"
#include "images/zombie.h"
#include "images/background2.h"

#include "images/winScreen.h"

u32 previousButtons;
u32 currentButtons;
/* TODO: */
// Add any additional states you need for your app. You are not requried to use
// these specific provided states.
enum gba_state {
  START,
  PLAY,
  PLAY2,
  WIN,
  LOSE,
};

char string[5];

int main(void) {
  /* TODO: */
  // Manipulate REG_DISPCNT here to set Mode 3. //
  REG_DISPCNT = MODE3 | BG2_ENABLE;
  REG_TM2D= -0x4000;          // 0x4000 ticks till overflow
  REG_TM2CNT= TM_FREQ_1024;   // we're using the 1024 cycle timer
  REG_TM3CNT= TM_ENABLE | TM_CASCADE;

  //u32 sec= -1;

  // Save current and previous state of button input.
  previousButtons=BUTTONS;
  currentButtons = BUTTONS;
  
  jumping = 0;
  
  

  // Load initial application state
  enum gba_state state = START;
    waitForVBlank();
    drawFullScreenImageDMA(startScreen);
    //score = 400;
  while (1) {
    waitForVBlank();
    currentButtons = BUTTONS; // Load the current state of the buttons
    
    /* TODO: */
    // Manipulate the state machine below as needed //
    // NOTE: Call waitForVBlank() before you draw
    
    
    
    switch (state) {
      case START:
      colorMeSurprised(20, COLOR(31, 0, 0));
      
      //drawFullScreenImageDMA(startScreen);
      if(KEY_JUST_PRESSED(BUTTON_START, currentButtons, previousButtons)) {
        count = 0;
        score=10;
        obj.row = 80;
        obj.col = 150;
        dream.row = 75;
        dream.col = 40;
        //drawImageDMA(120,80,240,160, background);
        drawFullScreenImageDMA(background);
        
        state = PLAY;
      }

        // state = ?
        break;
      case PLAY:

        undrawImage3(dream.row, dream.col, 19, 38, dreamImg);
        undrawImage3(obj.row, obj.col, 19,38, zombie);
        drawFullScreenImageDMA(background);
        if(KEY_HELD(BUTTON_SELECT, currentButtons, previousButtons)) { //BACKSPACE to go back to start any time.
          //drawFullScreenImageDMA(startScreen);
          
          state = START;
        }
        //char ch[44];
        //char *s;
        //snprintf(ch,100,"#{es;P:24,60}%02d:%02d:%02d", sec/3600, (sec%3600)/60, sec%60);
        //puts(ch);
        
        
        //if(REG_TM3D != sec)
        //{
            //sec= REG_TM3D;
            
          

            
        //}
        
        
        
        
        
        if(KEY_HELD(BUTTON_UP, currentButtons, previousButtons) || jumping == 1) {    
          jump(&dream);  
        
        }
        
        
        if(detectCollision(&dream, &obj) == -1) {
          score--;
          
          sprintf(string, "%d", score);
          drawString(20, 190, string, BLACK);
          
          if(score==0) {
            state = LOSE;
          }
        } 
      
        
        //moveZombie(&obj);
        move();
        
       
       if (240 < dream.col && dream.col < 260) { //go to next screen
          if(count == 1) {
            //
            state = WIN;
          } else {
          obj.row = 80;
          obj.col = 150;
          dream.row = 75;
          dream.col = 40;
          waitForVBlank();
          undrawImage3(obj.row, obj.col, 19,38, zombie);
          //drawFullScreenImageDMA(background2);
          //drawImageDMA(120, 80, 240, 160, background2);
          state = PLAY2;      
          }
          
          
        }
        drawFullScreenImageDMA(background);
        drawString(20, 147, "health:", BLACK);
        sprintf(string, "%d", score);
        drawString(20, 190, string, BLACK);
        
        drawImageDMA(dream.row, dream.col, 19, 38, dreamImg);
        
        drawImageDMA(obj.row, obj.col, 19, 38, zombie);
        delay(2);

        // state = ?
        break;
      case PLAY2:
      //waitForVBlank();
        count = 1;
        
      
        undrawImage3(dream.row, dream.col, 19, 38, dreamImg);
        undrawImage3(obj.row, obj.col, 19,38, zombie);
        drawFullScreenImageDMA(background2);
        if(KEY_HELD(BUTTON_SELECT, currentButtons, previousButtons)) { //BACKSPACE to go back to start any time.
          drawFullScreenImageDMA(startScreen);
          
          state = START;
        }
       
        
        
        if(KEY_HELD(BUTTON_UP, currentButtons, previousButtons) || jumping == 1) {    
          jump(&dream);  
        
        }
        drawString(20, 147, "health:", BLACK);
        sprintf(string, "%d", score);
        drawString(20, 190, string, BLACK);
        
        if(detectCollision(&dream, &obj) == -1) {
          score--;
          
          sprintf(string, "%d", score);
          drawString(20, 190, string, BLACK);
          
          if(score==0) {
            state = LOSE;
          }
        } 
      
        
        //moveZombie(&obj);
        move();
        
       
       if (240 < dream.col && dream.col < 260) { //go to next screen
          count = 1;
          obj.row = 80;
          obj.col = 150;
          dream.row = 75;
          dream.col = 40;
          drawFullScreenImageDMA(background);
          //drawFullScreenImageDMA(background2);
          //drawImageDMA(120, 80, 240, 160, winScreen);
          state = PLAY;
        }
        
        drawFullScreenImageDMA(background2);
        drawString(20, 147, "health:", BLACK);
        sprintf(string, "%d", score);
        drawString(20, 190, string, BLACK);
        
        drawImageDMA(dream.row, dream.col, 19, 38, dreamImg);
        
        drawImageDMA(obj.row, obj.col, 19, 38, zombie);
        
        delay(2);


        break;
      case WIN:
        //waitForVBlank();
        drawFullScreenImageDMA(winScreen);
        drawCenteredString(WIDTH/2-20, HEIGHT/2, 50, 50, "You Win. Press Start to try again.", WHITE); //start = enter
        char string3[5];
        sprintf(string3, "%d", score);
        drawString(20, 147, "health:", BLACK);
        drawString(20, 190, string, BLACK);
        if(KEY_JUST_PRESSED(BUTTON_START, currentButtons, previousButtons)) {
          count = 0;
          obj.row = 80;
          obj.col = 150;
          dream.row = 75;
          dream.col = 40;
          score=10;
          drawFullScreenImageDMA(startScreen);
          
          state = START;
      }

        // state = ?
        break;
      case LOSE:
        waitForVBlank();
        fillScreenDMA(BLACK);
        drawCenteredString(WIDTH/2-20, HEIGHT/2, 50, 50, "You Lose. Press Start to try again.", WHITE);
    
       
        if(KEY_JUST_PRESSED(BUTTON_START, currentButtons, previousButtons)) {
          obj.row = 80;
          obj.col = 150;
          dream.row = 75;
          dream.col = 40;
          score=10;
          drawFullScreenImageDMA(startScreen);
    
          state = START;
        }

        

        // state = ?
        break;
    }

    previousButtons = currentButtons; // Store the current state of the buttons
  }

  //UNUSED(previousButtons); // You can remove this once previousButtons is used

  return 0;
}
